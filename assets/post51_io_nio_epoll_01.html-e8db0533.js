import{_ as a,W as t,X as c,Z as e,$ as o,a0 as r,Y as n,G as i}from"./framework-b5535326.js";const d={},s=n('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>看到比较好的java IO异步编程比喻,全文转载</p><h2 id="正文" tabindex="-1"><a class="header-anchor" href="#正文" aria-hidden="true">#</a> 正文</h2><p>有一个养鸡的农场，里面养着来自各个农户（Thread）的鸡（Socket），每家农户都在农场中建立了自己的鸡舍（SocketChannel）</p><ul><li><code>BIO</code></li></ul><p>Block IO，每个农户盯着自己的鸡舍，一旦有鸡下蛋，就去做捡蛋处理；</p><ul><li><code>NIO</code></li></ul><p>No-Block IO-单Selector，农户们花钱请了一个饲养员（Selector），并告诉饲养员（register）如果哪家的鸡有任何情况（下蛋）均要向这家农户报告（select keys）；</p><ul><li><code>NIO</code></li></ul><p>No-Block IO-多Selector，当农场中的鸡舍逐渐增多时，一个饲养员巡视（轮询）一次所需时间就会不断地加长，这样农户知道自己家的鸡有下蛋的情况就会发生较大的延迟。怎么解决呢？没错，多请几个饲养员（多Selector），每个饲养员分配管理鸡舍，这样就可以减轻一个饲养员的工作量，同时农户们可以更快的知晓自己家的鸡是否下蛋了；</p><ul><li><code>Epoll模式</code></li></ul><p>如果采用Epoll方式，农场问题应该如何改进呢？其实就是饲养员不需要再巡视鸡舍，而是听到哪间鸡舍的鸡打鸣了（活跃连接），就知道哪家农户的鸡下蛋了；</p><ul><li><code>AIO</code></li></ul><p>Asynchronous I/O, 鸡下蛋后，以前的NIO方式要求饲养员通知农户去取蛋，AIO模式出现以后，事情变得更加简单了，取蛋工作由饲养员自己负责，然后取完后，直接通知农户来拿即可，而不需要农户自己到鸡舍去取蛋。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',15),p={href:"https://plantegg.github.io/2019/07/31/NIO%E5%92%8CEpoll/",target:"_blank",rel:"noopener noreferrer"};function h(_,u){const l=i("ExternalLinkIcon");return t(),c("div",null,[s,e("p",null,[o("以上来自： "),e("a",p,[o("https://plantegg.github.io/2019/07/31/NIO和Epoll/"),r(l)])])])}const O=a(d,[["render",h],["__file","post51_io_nio_epoll_01.html.vue"]]);export{O as default};
