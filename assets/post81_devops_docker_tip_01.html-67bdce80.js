import{_ as n,W as d,X as o,Z as e,$ as a,a0 as i,Y as r,G as c}from"./framework-b5535326.js";const t={},s=r(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p><code>Dockerfile</code>是建立Docker镜像的基础描述文件，了解和学习怎么高效编写Dockerfile。</p><p>一个高效的Dockerfile，最终实现的目标是可以构建出更小的镜像，加快构建速度。</p><h2 id="正文" tabindex="-1"><a class="header-anchor" href="#正文" aria-hidden="true">#</a> 正文</h2><ul><li>尽量使用国内的基础镜像</li><li>尽量使用小的、够用基础镜像；</li><li>尽量排除掉无关的目录文件；</li><li>减少和控制Docker Layer层数量；</li><li>把不变层放到前面，可变层放到后面；</li><li>使用多阶段来分离build和runtime;</li></ul><h3 id="尽量使用国内的基础镜像" tabindex="-1"><a class="header-anchor" href="#尽量使用国内的基础镜像" aria-hidden="true">#</a> 尽量使用国内的基础镜像</h3><p>因为网络原因，使用国内基础镜像源毋庸置疑会加快构建速度。</p><ul><li>例如，使用<code>From</code>指令指定使用阿里云或本地先<code>docker pull</code></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>From registry.cn-beijing.aliyuncs.com/yournamespace/openjdk:8-jdk-alpine；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="尽量使用小的-够用基础镜像" tabindex="-1"><a class="header-anchor" href="#尽量使用小的-够用基础镜像" aria-hidden="true">#</a> 尽量使用小的，够用基础镜像</h3><blockquote><p>可以考虑使用各种alpine镜像，但要注意一些已知问题</p></blockquote><h3 id="尽量排除掉无关的目录文件" tabindex="-1"><a class="header-anchor" href="#尽量排除掉无关的目录文件" aria-hidden="true">#</a> 尽量排除掉无关的目录文件</h3><ul><li>不要放入无关的文件到构建目录；</li><li>可以使用 <code>.dockerignore</code> 来忽略这些文件</li></ul><h3 id="减少和控制docker-layer层数量" tabindex="-1"><a class="header-anchor" href="#减少和控制docker-layer层数量" aria-hidden="true">#</a> 减少和控制Docker Layer层数量</h3><ul><li>多条<code>RUN</code>指令可以使用<code>&amp;&amp;</code>连接起来作为一条指令执行。因为一条指令就是加一层。例如：</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>RUN yum install -y git &amp;&amp;  yum install -y nginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>如有安装应用，适当清理缓存数据。例如：</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>FROM centos
RUN yum install -y git &amp;&amp; \\
    yum install -y nginx &amp;&amp; \\
    yum clean all &amp;&amp; rm -rf /var/cache/yum/*
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="不变层的指令放到前面-常变层放到后面" tabindex="-1"><a class="header-anchor" href="#不变层的指令放到前面-常变层放到后面" aria-hidden="true">#</a> 不变层的指令放到前面，常变层放到后面</h3><blockquote><p>这样做的原因是，不变层可以缓存，下次构建可以复用,节省带宽和时间。</p></blockquote><h3 id="使用多阶段来分离build和runtime-重要" tabindex="-1"><a class="header-anchor" href="#使用多阶段来分离build和runtime-重要" aria-hidden="true">#</a> 使用多阶段来分离build和runtime （重要）</h3><blockquote><p>使用多阶段得方式，可以大大降低镜像大小。实现应用构建环境和运行环境分离，最终只需要把运行环境的依赖打包到应用镜像中。</p></blockquote><blockquote><p>在Dockerfile中使用多个FROM声明，每个FROM声明可以使用不同的基础镜像</p></blockquote><p>例如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>FROM golang:1.17.6 AS BUILDER
ADD . /go/src/github.com/golang/example
RUN go build -o /go/src/github.com/golang/example/hello /go/src/github.com/golang/example/hello/hello.go

FROM golang:1.17.6-alpine
WORKDIR /go/src/github.com/golang/example
COPY --from=BUILDER /go/src/github.com/golang/example/hello /go/src/github.com/golang/example/hello
ENTRYPOINT [&quot;/go/src/github.com/golang/example/hello&quot;]

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>两条<code>FROM</code>指令，意味两个阶段。</li><li>第一条<code>FROM</code>指令时应用构建阶段，并使用关键字<code>AS</code>来命名应用构建阶段 &quot;BUILDER&quot;。</li><li>第二条<code>FROM</code>指令起则是运行Runtime阶段，并使用<code>COPY --from=BUILDER</code> 把应用构建结果加入到应用镜像中，不需要的例如SDK则抛弃。</li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>`,27),u={href:"http://coinxu.github.io/blog/docker/4-3-use-multi-stage-builds.html",target:"_blank",rel:"noopener noreferrer"},h={href:"https://developer.aliyun.com/article/861395?utm_content=m_1000321658",target:"_blank",rel:"noopener noreferrer"};function m(p,g){const l=c("ExternalLinkIcon");return d(),o("div",null,[s,e("ul",null,[e("li",null,[e("p",null,[e("a",u,[a("使用多阶段构建"),i(l)])])]),e("li",null,[e("p",null,[e("a",h,[a("编写更高效 Dockerfile - 阿里云 云效工程师指北"),i(l)])])])])])}const v=n(t,[["render",m],["__file","post81_devops_docker_tip_01.html.vue"]]);export{v as default};
